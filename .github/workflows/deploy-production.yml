name: Production Deployment Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_RESOURCE_GROUP: 'order-catalog-prod-rg'
  AKS_CLUSTER_NAME: 'order-catalog-prod-aks'
  ACR_NAME: 'ordercatalogprodacr'
  IMAGE_NAME: 'order-catalog-service'
  NAMESPACE: 'production'

jobs:
  # ═══════════════════════════════════════════════════════════
  # JOB 1: BUILD & UNIT TESTS
  # ═══════════════════════════════════════════════════════════
  build:
    name: Build & Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Full history for SonarQube
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore --locked-mode
      working-directory: ./src
    
    - name: Build solution
      run: dotnet build --configuration Release --no-restore
      working-directory: ./src
    
    - name: Run unit tests (parallel)
      run: |
        dotnet test \
          --configuration Release \
          --no-build \
          --verbosity normal \
          --logger "trx;LogFileName=test-results.trx" \
          --logger "GitHubActions" \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults \
          -- NUnit.NumberOfTestWorkers=auto
      working-directory: ./src
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: unit-test-results
        path: ./src/TestResults/**/*
        retention-days: 7
    
    - name: Code coverage report
      uses: codecov/codecov-action@v3
      with:
        files: ./src/TestResults/**/coverage.cobertura.xml
        flags: unittests
        fail_ci_if_error: true

  # ═══════════════════════════════════════════════════════════
  # JOB 2: INTEGRATION TESTS (Testcontainers)
  # ═══════════════════════════════════════════════════════════
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build
    
    services:
      # Docker-in-Docker for Testcontainers
      docker:
        image: docker:dind
        options: --privileged
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Start Testcontainers
      run: |
        docker network create test-network || true
        
        # PostgreSQL
        docker run -d \
          --name postgres-test \
          --network test-network \
          -e POSTGRES_PASSWORD=testpass \
          -e POSTGRES_DB=testdb \
          -p 5432:5432 \
          postgres:15-alpine
        
        # Redis
        docker run -d \
          --name redis-test \
          --network test-network \
          -p 6379:6379 \
          redis:7-alpine
        
        # Wait for services
        sleep 10
    
    - name: Run integration tests
      env:
        ConnectionStrings__PostgreSQL: "Host=localhost;Database=testdb;Username=postgres;Password=testpass"
        ConnectionStrings__Redis: "localhost:6379"
      run: |
        dotnet test \
          --configuration Release \
          --filter "Category=Integration" \
          --logger "trx;LogFileName=integration-test-results.trx" \
          --logger "GitHubActions" \
          --collect:"XPlat Code Coverage"
      working-directory: ./src
    
    - name: Cleanup containers
      if: always()
      run: |
        docker stop postgres-test redis-test || true
        docker rm postgres-test redis-test || true

  # ═══════════════════════════════════════════════════════════
  # JOB 3: SECURITY SCANNING
  # ═══════════════════════════════════════════════════════════
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Snyk vulnerability scan
      uses: snyk/actions/dotnet@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high --fail-on=upgradable
    
    - name: SonarQube scan
      uses: sonarsource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      with:
        args: >
          -Dsonar.projectKey=order-catalog-service
          -Dsonar.coverage.exclusions=**/*Tests/**
          -Dsonar.cs.opencover.reportsPaths=**/TestResults/**/coverage.opencover.xml
    
    - name: OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'order-catalog-service'
        path: './src'
        format: 'HTML'
        args: >
          --failOnCVSS 7
          --enableRetired

  # ═══════════════════════════════════════════════════════════
  # JOB 4: BUILD & PUSH DOCKER IMAGE
  # ═══════════════════════════════════════════════════════════
  docker-build:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build, integration-tests, security-scan]
    if: github.ref == 'refs/heads/main'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:latest
          network=host
    
    - name: Log in to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.ACR_NAME }}.azurecr.io
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push
      uses: docker/build-push-action@v5
      with:
        context: ./src
        file: ./src/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:buildcache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          DOTNET_VERSION=${{ env.DOTNET_VERSION }}
        platforms: linux/amd64
    
    - name: Scan image with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
    
    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  # ═══════════════════════════════════════════════════════════
  # JOB 5: DEPLOY INFRASTRUCTURE (Bicep)
  # ═══════════════════════════════════════════════════════════
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: docker-build
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Validate Bicep templates
      run: |
        az bicep build --file ./infrastructure/main.bicep
        az deployment sub validate \
          --location eastus \
          --template-file ./infrastructure/main.bicep \
          --parameters environment=prod
    
    - name: Deploy infrastructure
      run: |
        az deployment sub create \
          --name "infra-deployment-${{ github.run_number }}" \
          --location eastus \
          --template-file ./infrastructure/main.bicep \
          --parameters \
            environment=prod \
            appName=order-catalog \
          --confirm-with-what-if
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
    
    - name: Verify cluster connectivity
      run: |
        kubectl cluster-info
        kubectl get nodes

  # ═══════════════════════════════════════════════════════════
  # JOB 6: CANARY DEPLOYMENT (10% Traffic)
  # ═══════════════════════════════════════════════════════════
  canary-deployment:
    name: Canary Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [docker-build, deploy-infrastructure]
    if: github.ref == 'refs/heads/main'
    
    environment:
      name: production-canary
      url: https://api.company.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }}
    
    - name: Deploy canary (10% traffic)
      run: |
        kubectl apply -f - <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: order-service-canary
          namespace: ${{ env.NAMESPACE }}
          labels:
            app: order-service
            version: canary
        spec:
          replicas: 2  # 10% of 20 total pods
          selector:
            matchLabels:
              app: order-service
              version: canary
          template:
            metadata:
              labels:
                app: order-service
                version: canary
            spec:
              containers:
              - name: order-service
                image: ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: 1000m
                    memory: 2Gi
                  limits:
                    cpu: 2000m
                    memory: 4Gi
                env:
                - name: ASPNETCORE_ENVIRONMENT
                  value: "Production"
                - name: DEPLOYMENT_VERSION
                  value: "canary-${{ github.sha }}"
                livenessProbe:
                  httpGet:
                    path: /health/live
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health/ready
                    port: 8080
                  initialDelaySeconds: 10
                  periodSeconds: 5
        EOF
    
    - name: Wait for canary pods
      run: |
        kubectl wait --for=condition=ready pod \
          -l app=order-service,version=canary \
          -n ${{ env.NAMESPACE }} \
          --timeout=300s
    
    - name: Monitor canary metrics (5 minutes)
      run: |
        echo "Monitoring canary deployment for 5 minutes..."
        
        for i in {1..30}; do
          echo "Check $i/30"
          
          # Get error rate
          ERROR_RATE=$(kubectl logs -l app=order-service,version=canary -n ${{ env.NAMESPACE }} --tail=100 | grep -c "ERROR" || true)
          
          # Get response time P95 (from metrics endpoint)
          P95=$(kubectl exec -n ${{ env.NAMESPACE }} deploy/order-service-canary -- \
            curl -s http://localhost:8080/metrics | \
            grep 'http_request_duration_seconds_bucket' | \
            awk '{print $2}' | \
            sort -n | \
            awk 'BEGIN{c=0} {c++; val[c]=$1} END{print val[int(c*0.95)]}')
          
          echo "Error rate: $ERROR_RATE, P95 latency: $P95"
          
          # Rollback if error rate > 1%
          if [ "$ERROR_RATE" -gt 10 ]; then
            echo "ERROR: Canary error rate too high, rolling back!"
            kubectl delete deployment order-service-canary -n ${{ env.NAMESPACE }}
            exit 1
          fi
          
          sleep 10
        done
        
        echo "Canary validation passed!"

  # ═══════════════════════════════════════════════════════════
  # JOB 7: FULL PRODUCTION DEPLOYMENT
  # ═══════════════════════════════════════════════════════════
  production-deployment:
    name: Production Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: canary-deployment
    if: github.ref == 'refs/heads/main'
    
    environment:
      name: production
      url: https://api.company.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }}
    
    - name: Deploy to production
      run: |
        kubectl set image deployment/order-service \
          order-service=${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -n ${{ env.NAMESPACE }}
        
        kubectl rollout status deployment/order-service -n ${{ env.NAMESPACE }} --timeout=600s
    
    - name: Remove canary deployment
      run: |
        kubectl delete deployment order-service-canary -n ${{ env.NAMESPACE }} || true
    
    - name: Verify deployment
      run: |
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=order-service
        kubectl get svc -n ${{ env.NAMESPACE }}

  # ═══════════════════════════════════════════════════════════
  # JOB 8: LOAD TESTING (k6)
  # ═══════════════════════════════════════════════════════════
  load-test:
    name: Load Testing
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: production-deployment
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup k6
      run: |
        sudo gpg -k
        sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
    
    - name: Run load test
      run: |
        k6 run --out json=results.json ./tests/load/black-friday-test.js
      env:
        API_BASE_URL: https://api.company.com
        API_KEY: ${{ secrets.API_KEY }}
    
    - name: Validate results
      run: |
        # Parse k6 results
        P95=$(cat results.json | jq '.metrics.http_req_duration.values.p95')
        ERROR_RATE=$(cat results.json | jq '.metrics.http_req_failed.values.rate')
        
        echo "P95 Latency: $P95 ms"
        echo "Error Rate: $ERROR_RATE %"
        
        # Assert thresholds
        if (( $(echo "$P95 > 150" | bc -l) )); then
          echo "FAIL: P95 latency exceeds 150ms threshold"
          exit 1
        fi
        
        if (( $(echo "$ERROR_RATE > 0.1" | bc -l) )); then
          echo "FAIL: Error rate exceeds 0.1% threshold"
          exit 1
        fi
        
        echo "Load test passed!"
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      with:
        name: load-test-results
        path: results.json

  # ═══════════════════════════════════════════════════════════
  # JOB 9: SMOKE TESTS
  # ═══════════════════════════════════════════════════════════
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: production-deployment
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run smoke tests
      run: |
        ./tests/smoke/run-smoke-tests.sh
      env:
        API_BASE_URL: https://api.company.com
        API_KEY: ${{ secrets.API_KEY }}

  # ═══════════════════════════════════════════════════════════
  # JOB 10: NOTIFY
  # ═══════════════════════════════════════════════════════════
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [production-deployment, load-test, smoke-tests]
    if: always()
    
    steps:
    - name: Send Slack notification
      uses: slackapi/slack-github-action@v1
      with:
        payload: |
          {
            "text": "Deployment ${{ job.status }}",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Order Catalog Service* deployment to production ${{ job.status }}\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}"
                }
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}